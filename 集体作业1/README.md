# 集体作业1

本次作业作为模拟考试，难度略高，包含了一些此前几年期中考试的困难题目，题量和代码量也比较大；但是每一个题目都可以依据此前作业题练习的知识点进行求解。

## 求亲和数

假设我们有了函数factor_sum(num)可以直接求num的所有除本身之外的因数之和，那么判断数a是否是一对n范围内的亲和数中的较小数，需要满足如下条件。

1. factor_sum(a) > a，即a是较小数；
2. factor_sum(a) <= n，即a的因数和在n的范围之中；
3. factor_sum(factor_sum(a)) == a，即a是一对亲和数中的一个。

因此，只要有了一个能快速判定的函数factor_sum，扫描n以内所有数字即可。

最简单的factor_sum如下所示，直接暴力扫描寻找num的所有因数。暴力的方法一定会超时，因为它的复杂度过高。对于num来说，factor_sum的复杂度是O(num)的（即运算量随num增大而线性增长）；而求解整个问题需要调用factor_sum扫描n一下所有正整数，因此求解整个问题的复杂度是O(n^2)的（即运算量随n增大而二次增长）。n最大是100k，运算量规模为n的二次方，也就是10G，远超计算机1s的运算量（大约在1G-5G左右）。综上所述，直接暴力求解是不可行的。

```cpp
int factor_sum(int num)
{
    int sum = 0;
    for (int i = 1; i < num; i++)
        if (num % i == 0)
            sum += i;
    return sum;
}
```

通过分析，可以发现其实并不需要真的扫描小于num的所有数来寻找因数。首先，大于num / 2的所有数显然都是不用扫描的，然而这样并不会降低复杂度，因为计算量还是与num的大小成线性关系；接下来，我们可以发现，num的每个因数a都会存在另一个成对的因数b，使得a * b == num——这意味着只需要扫描sqrt(num)以下的数字即可。优化过的factor_sum如下所示。函数存在两个边界的特判，a) 与1成对的是num本身，因而需要剔除；b) 若num为完全平方数，那么其平方根与自身成对，因此只能计算一次，需要特判。

```cpp
int factor_sum(int num)
{
    int sum = - num, _sqrt = int(sqrt(num));
    for (int i = 1; i * i < num; i++)
        if (num % i == 0)
            sum += i + num / i;
    if (_sqrt * _sqrt == num)   // 特判平方根
        sum += _sqrt;
    return sum;
}
```

优化过的factor_sum本身的复杂度是O(sqrt num)（即运算量随输入num增大而对数增长）；使用优化过的factor_sum来求解整个问题，复杂度是O(n^(3/2))（即运算量随n增大而与n的三分之二次方同规模增长）。此时运算量规模大致为30M，是可以接受的。

## 求交集

该题目具有两个难点——a) 处理输入数据，和b) 求取交集。

处理输入数据可以采用如下的方法。读入一个数字后，使用cin.get判断数字之后的字符是','还是'\n'，对应的是本行还有数字没有读完以及本行已经结束。

```cpp
// A数组存放一行中的数字，na为存放数字的个数
do
    cin >> A[na++];
while(cin.get() != '\n');
```

求取数组A和数组B的交集可以参考下面的算法。

```
1. 将A和B两个数组分别从小到大排序
2. 下标i = 0，j = 0，分别指向A和B的第一个元素（即最小元素）；last = None，记录最近一次找到的交集中的元素，初始化为“无”
3. 若A[i] == B[j]，则说明找到一个交集中的元素
    3.1 若A[i] != last，则说明该元素是新找到的交集中的元素，输出A[i]并更新last为A[i]
    3.2 否则A[i] == last，说明该元素已经出现在已知的交集中，不做操作
    3.3 i和j均右移一位
4. 若A[i] < B[j]，则说明A[i]一定不在交集之中
    4.1 i右移一位
5. 若A[i] > B[j]，则说明B[j]一定不在交集之中
    5.1 j右移一位
6. 若i == na或j == nb，则说明A或B已经全部被扫描过，终止并返回
7. 否则继续扫描，跳至3
```

## 旋转输出矩阵

题目描述比较花哨，但其实本质上就是先找出旋转输出的序列，然后一前一后将该序列打印。下面介绍如何方便地进行旋转输出矩阵。

旋转输出矩阵时，从左上角起，向右输出元素，之后向下，向左，向上，向右...循环直至全部输出。在二维数组arr中，左上角为arr[0][0]，对于元素arr[i][j]来说，各个方向如下表所示。我们可以将方向存放在数组中，使用变量d来表示方向，d从0到3循环即可。

| 方向 | 位置 |
|-|-|
| 右 | i, j + 1 |
| 下 | i + 1, j |
| 左 | i, j - 1 |
| 上 | i - 1, j |

将旋转输出的序列存放在数组out中，之后一前一后输出out即可。需要考虑out的长度是奇数还是偶数。

## 细菌的繁殖与扩散

每一天的细菌分布情况都与前一天相关，因此可以使用之前介绍过的双缓冲区的方式来计算。在计算的过程中同样可以使用方向数组和循环来计算每个位置的八个方向。

直接参考代码即可。

## 流感传染

该题目可以使用双缓冲区的方式来求解，但是其实还可以更为简单。简单分析即可发现，病人从得病起永远都是病人（即得病后，状态不再变化），而健康人才可能得病（即健康人的状态可以改变一次，对应得病），因此我们可以直接在同一个矩阵上不断操作更新状态。

一个房间可能出现的状态如下表所示。第i天时，所有状态为正且状态小于等于i的病人会传染周围的健康人，健康人被传染后，状态从0变为i+1。这样的算法设计，会使得第i天被传染的人在当天并不会传染别人，而是在下一天才开始传染。

| 状态 | 含义 |
|-|-|
| -1 | 无人居住 |
| 0 | 健康人居住 |
| k > 0 | 在第k天得病的病人 |

## 一类括号匹配问题

括号匹配与栈数据结构的特性相同。栈的特性是先进后出，与括号匹配的性质相同。使用栈来进行括号匹配的过程如下表所示。若栈空时输入了)，或输入空时栈不空，则说明括号不匹配。将匹配好的括号，按题目要求进行排序并输出即可。

| 栈 | 待处理序列 | 操作 | 已有的匹配好的括号 |
|-|-|-|-|
| 底 顶 | ( (()()))() | (，入栈 | 无 |
| 底 ( 顶 | ( ()()))() | (，入栈 | 无 |
| 底 (( 顶 | ( )()))() | (，入栈 | 无 |
| 底 ((( 顶 | ) ()))() | )，与栈顶(匹配，弹栈 | (3, 4) |
| 底 (( 顶 | ( )))() | (，入栈 | (3, 4) |
| 底 ((( 顶 | ) ))() | )，与栈顶(匹配，弹栈 | (3, 4) (5, 6) |
| 底 (( 顶 | ) )() | )，与栈顶(匹配，弹栈 | (3, 4) (5, 6) (2, 7) |
| 底 ( 顶 | ) () | )，与栈顶(匹配，弹栈 | (3, 4) (5, 6) (2, 7) (1, 8) |
| 底 顶 | ( ) | (，入栈 | (3, 4) (5, 6) (2, 7) (1, 8) |
| 底 ( 顶 | ) | )，与栈顶(匹配，弹栈 | (3, 4) (5, 6) (2, 7) (1, 8) (9, 10) |
| 底 顶 | 空 | 栈空且待处理序列空，完成匹配！ | (3, 4) (5, 6) (2, 7) (1, 8) (9, 10) |

在该题目中，不需要使用栈这种比较复杂的数据结构，我们可以将栈简化为计数cnt。与上面的过程相同的，使用cnt计数来进行括号匹配的过程如下表所示。若cnt为0时输入了)，或cnt > 0时输入空，则说明括号不匹配。

| 计数 | 待处理序列 | 操作 | 已有的匹配好的括号 |
|-|-|-|-|
| 0 | ( (()()))() | (，计数加一 | 无 |
| 1 | ( ()()))() | (，计数加一 | 无 |
| 2 | ( )()))() | (，计数加一 | 无 |
| 3 | ) ()))() | )，存在(与之匹配，计数减一 | (3, 4) |
| 2 | ( )))() | (，计数加一 | (3, 4) |
| 3 | ) ))() | )，存在(与之匹配，计数减一 | (3, 4) (5, 6) |
| 2 | ) )() | )，存在(与之匹配，计数减一 | (3, 4) (5, 6) (2, 7) |
| 1 | ) () | )，存在(与之匹配，计数减一 | (3, 4) (5, 6) (2, 7) (1, 8) |
| 0 | ( ) | (，计数加一 | (3, 4) (5, 6) (2, 7) (1, 8) |
| 1 | ) | )，存在(与之匹配，计数减一 | (3, 4) (5, 6) (2, 7) (1, 8) (9, 10) |
| 0 | 空 | 计数为零且待处理序列空，完成匹配！ | (3, 4) (5, 6) (2, 7) (1, 8) (9, 10) |

## 判断四边形

作业原题，不再赘述

## 神奇的幻方

比较简单，按照题目要求在数组中填写即可，不再赘述。

## 打印月历

该题目难点主要有两个——a) 计算待输出月1号是星期几，和b) 宽度为4的规范化打印。

计算星期需要首先计算从1900年1月1日（已知星期一）起到待输出年待输出月1日共有多少天，在之前的作业中已经详细解释过如何完成，不再赘述。当知道了天数后，可以直接模7计算星期。

宽度为4的规范化打印可以通过printf，如下所示。

```cpp
int d = 22;
printf("%4d", d);
// 打印出"  22"，"%4d"要求打印宽度为4的整型数据，左侧补空格
```