# 第三阶段编程练习3

## 前缀表达式

前缀表达式是三种表达式（前缀，中缀，后缀）之中最好计算的表达式，每个操作符都只需要利用其后的两个表达式或数值进行计算。递归函数如下。

```cpp
double func()
{
    char str[MAX_LEN] = "\0";
    double val = 0;
    scanf("%s", str);   // 读入当前的操作符或数字
    switch (str[0])
    {
    case '+': val = func() + func(); break; // 四种二元操作符
    case '-': val = func() - func(); break; // 利用其后的两个表达式计算
    case '*': val = func() * func(); break;
    case '/': val = func() / func(); break;
    default: val = atof(str); break;        // 不是操作符，直接返回数值
    }
    return val;
}
```

## 平衡矩阵

该题目中需要移动矩阵的某些行，直接移动的话操作比较复杂，可以采用偏移量的方法。原始的二维数组为arr，每一行左移的次数都存放在offset数组中，假设移动后的数组为arr_。那么很显然有arr_[i][j] == arr[i][(j + offset[i]) % n]。这样设计数据结构，使得移动这个操作非常简单。

在有了计算矩阵各列和的最大值的函数calc之后，可以写出递归函数如下，其中每一行都左移n次，恰好可以恢复到初始状态。

```cpp
void func(int idx)
{
	if (idx >= n)   // 所有行都操作过，终止并计算calc
    {
        int tmp = calc();
        if (res > tmp)
            res = tmp;
		return;
	}
	for (int i = 0; i < n; i++) // 左移n次
	{
		offset[idx] = i;
		func(idx + 1);  // 每一次移动都递归调用func
	}
	return;
}
```

## K进制数的子序列

题目可以分作两部分，第一部分在于使用大整数加法计算所有序列，第二部分在于五个一行的输出。大整数计算之前的作业中已经出现过多次，不再赘述。五个一行输出可以使用如下代码。

```cpp
for (int i = 0; i < m; i++)
{
    addone();   // 计算当前需要输出的K进制数
    cout << s;  // 输出该数字
    if (i != m - 1) // 若该数不是最后一个数
    {
        if (i % 5 == 4) // 第五个，换行
            cout << endl;
        else            // 否则输出逗号
            cout << ",";
    }
}
```

## 分解因数

该题目基本没有难度，直接参考下面的递归函数即可。

```cpp
int func(int n, int start)  // 整数n，从start起开始分解，有多少种分解方法
{
	int res = 0;
	for (int i = start; i * i <= n; i++)
		if (n % i == 0)
			res += func(n / i, i);
	return res + 1; // 这个数本身也是一种分解方法
}
```

## 硬币面值组合

该题目基本没有难度，可能出现问题的地方在于输出，可以使用的方法如下。

1. cout << setfill('0') << setw(3) << SOMETHING; 使用字符'0'进行填充，要求宽度为3。
2. printf("%03d", SOMETHING); 使用字符'0'进行填充，要求宽度为3。

## 简单的缩略语判断

第二阶段编程练习6中的题目，不再赘述。

## 布尔表达式

计算布尔表达式的标准做法是使用栈的数据结构。栈的结构在之前的作业中介绍过，先进后出是其重要性质。可以将栈想象为一摞煎饼，每一张饼都是栈中的一个元素，新的饼只能堆在这一摞煎饼的顶端（入栈的元素都只能放在栈的顶端），取煎饼时也只能从上往下一个一个取而不能直接取中间的某一个（取元素或查看元素都只能是顶端元素，而不能直接取或查看任意元素）。使用两个栈来计算一个布尔表达式的例子如下。

| 符号栈 | 数值栈 | 待处理序列 | 操作 |
|-|-|-|-|
| | | ( F & F \| V \| ! V & ! F & ! ( F \| F & V ) ) | (入符号栈 |
| ( | | F & F \| V \| ! V & ! F & ! ( F \| F & V ) ) | F入数值栈 |
| ( | F | & F \| V \| ! V & ! F & ! ( F \| F & V ) ) | 符号栈顶无优先级高于&的，&入符号栈 |
| ( & | F | F \| V \| ! V & ! F & ! ( F \| F & V ) ) | F入数值栈 |
| ( & | F F | \| V \| ! V & ! F & ! ( F \| F & V ) ) | 符号栈顶&优先级高于\|，符号栈顶一个符号和数值栈顶两个数据弹栈运算，结果入符号栈 |
| ( | F | \| V \| ! V & ! F & ! ( F \| F & V ) ) | 符号栈顶无优先级高于\|的，\|入符号栈 |
| ( \| | F | V \| ! V & ! F & ! ( F \| F & V ) ) | V入数值栈 |
| ( \| \| | F V | ! V & ! F & ! ( F \| F & V ) ) | 符号栈顶无优先级高于!的，!入符号栈 |
| ( \| \| ! | F V | V & ! F & ! ( F \| F & V ) ) | V入数值栈 |
| ( \| \| ! | F V V | & ! F & ! ( F \| F & V ) ) | 符号栈顶!优先级高于&，符号栈顶一个符号和数值栈顶一个数据弹栈运算，结果入符号栈 |
| ( \| \| | F V F | & ! F & ! ( F \| F & V ) ) | 符号栈顶无优先级高于&的，&入符号栈 |
| ( \| \| & | F V F | ! F & ! ( F \| F & V ) ) | 符号栈顶无优先级高于!的，!入符号栈 |
| ( \| \| & ! | F V F | F & ! ( F \| F & V ) ) | F入数值栈 |
| ( \| \| & ! | F V F F | & ! ( F \| F & V ) ) | 符号栈顶!优先级高于&，符号栈顶一个符号和数值栈顶一个数据弹栈运算，结果入符号栈 |
| ( \| \| & | F V F V | & ! ( F \| F & V ) ) | 符号栈顶无优先级高于&的，&入符号栈 |
| ( \| \| & & | F V F V | ! ( F \| F & V ) ) | 符号栈顶无优先级高于!的，!入符号栈 |
| ( \| \| & & ! | F V F V | ( F \| F & V ) ) | (入符号栈 |
| ( \| \| & & ! ( | F V F V | F \| F & V ) ) | F入数值栈 |
| ( \| \| & & ! ( | F V F V F | \| F & V ) ) | 符号栈顶无优先级高于\|的，\|入符号栈 |
| ( \| \| & & ! ( \| | F V F V F | F & V ) ) | F入数值栈 |
| ( \| \| & & ! ( \| | F V F V F F | & V ) ) | 符号栈顶无优先级高于&的，&入符号栈 |
| ( \| \| & & ! ( \| & | F V F V F F | V ) ) | V入数值栈 |
| ( \| \| & & ! ( \| & | F V F V F F V | ) ) | 栈顶不是(，符号栈顶一个符号和数值栈顶两个数据弹栈运算，结果入符号栈 |
| ( \| \| & & ! ( \| | F V F V F F | ) ) | 栈顶不是(，符号栈顶一个符号和数值栈顶两个数据弹栈运算，结果入符号栈 |
| ( \| \| & & ! ( | F V F V F | ) ) | 栈顶是(，符号栈弹栈 |
| ( \| \| & & ! | F V F V F | ) | 栈顶不是(，符号栈顶一个符号和数值栈顶一个数据弹栈运算，结果入符号栈 |
| ( \| \| & & | F V F V V | ) | 栈顶不是(，符号栈顶一个符号和数值栈顶两个数据弹栈运算，结果入符号栈 |
| ( \| \| & | F V F V | ) | 栈顶不是(，符号栈顶一个符号和数值栈顶两个数据弹栈运算，结果入符号栈 |
| ( \| \| | F V F | ) | 栈顶不是(，符号栈顶一个符号和数值栈顶两个数据弹栈运算，结果入符号栈 |
| ( \| | F V | ) | 栈顶不是(，符号栈顶一个符号和数值栈顶两个数据弹栈运算，结果入符号栈 |
| ( | V | ) | 栈顶是(，符号栈弹栈 |
| | V | | 符号栈空，待处理序列空，完成！返回数值栈顶元素V |

上面的例子看起来非常复杂，但其实根据待处理序列中的首个元素，一共只有7种不同的操作。

1. 待处理元素为(，则(入符号栈
2. 待处理元素为)，则运算（运算的操作在之后讲解），直至从符号栈中弹出一个(为止
3. 待处理元素为V或F，则该元素入数值栈
4. 待处理元素为!，则!入符号栈
5. 待处理元素为&，(a) 且栈顶不是!，则&入符号栈，或(b) 且栈顶为!，则运算直至栈顶不是!，之后&入符号栈
6. 待处理元素为\|，(a) 且栈顶不是!或&，则\|入符号栈，或(b) 且栈顶为!或&，则运算直至栈顶不是!或&，之后\|入符号栈
7. 待处理序列为空，则运算直至符号栈为空

运算的操作其实就是使用数值栈和符号栈的栈顶元素进行计算，并将结果重新放回数值栈中。有如下三种情况

1. 若符号栈顶为!，则弹出数符号顶的!和数值栈顶的一个元素a，将a取反后入数值栈
2. 若符号栈顶为&，则弹出数符号顶的&和数值栈顶的两个元素a和b，将a和b取与后入数值栈
3. 若符号栈顶为\|，则弹出数符号顶的\|和数值栈顶的两个元素a和b，将a和b取或后入数值栈

最后，再说明一下如何使用数组实现一个栈。

```cpp
// 用数组定义一个栈
char stack[MAX_N] = {0};    // 栈
int n = 0;                  // 栈顶位置
// 压栈/入栈
stack[n++] = SOMETHING;     // 将某元素压入栈顶
// 弹栈/出栈
SOME_VAR = stack[--n];     // 将栈顶元素弹出并赋给某变量
```

## 四则运算

该题目的中缀表达式也可以使用前面介绍的栈来进行计算。不过在这里介绍另一种递归的方法。

在已经知道了整个式子之后，第一步的计算只可能有如下4种情况，且这4种情况优先级递减。

1. 整个式子就是一整个数字，此时直接得到数值
2. 整个式子处于一对括号之中，此时直接去掉括号，计算剩下的部分即可
3. 式子之中存在\*或/，此时从左到右计算乘法和除法，且操作数分别是\*和/左右的两个式子
4. 式子之中存在+或-，此时从左到右计算加法和减法，且操作数分别是+和-左右的两个式子

显然这样就是可以递归的形式，递归函数如下。由于递归是类似于栈的，因此递归中的顺序与优先级相反。

```cpp
int compute(int l, int r)
{
	for (int i = r; i >= l; i--)    // 加减法
    {
		if (a[i] == ')')
			i = matched(l, i);  // 匹配括号
		if (a[i] == '+')
			return compute(i + 1, r) + compute(l, i - 1);
		if (a[i] == '-')
			return compute(l, i - 1) - compute(i + 1, r);
	}
	for (int i = r; i >= l; i--)    // 乘除法
	{
		if (a[i] == ')')
			i = matched(l, i);
		if (a[i] == '*')
			return compute(i + 1, r) * compute(l, i - 1);
		if (a[i] == '/')
			return compute(l, i - 1) / compute(i + 1, r);
	}
	if (a[r] == ')')                // 括号
		return compute(l + 1, r - 1);
	if (a[r] >= '0' && a[r] <= '9') // 数字
	{
		int ans = 0, j = 0;
		for (int i = r; i >= l; i--, j++)
			ans += pow(10.0, (double)j) * (a[i] - '0');
		return ans;
	}
	return 0;
}
```

## 全排列

直接递归搜索排列即可，递归函数如下。

```cpp
char s[MAX_LEN] = "\0";
bool visited[MAX_LEN] = {false};
int idx[MAX_LEN] = {0};

void func(int depth)
{
	if (s[depth] == '\0')
    {
		for (int i = 0; s[i] != '\0'; i++)
			cout << s[idx[i]];
		cout << endl;
		return;
	}
	for (int i = 0; s[i] != '\0'; i++)
		if (!visited[i])    // 若没有出现过
		{
			visited[i] = true;
			idx[depth] = i;
			func(depth + 1);
			visited[i] = false; // 回溯
		}
	return;
}
```

## 带通配符的字符串匹配

该题目是典型的动态规划（Dynamic Programming，DP）题目。首先简单介绍一下什么是动态规划，我们通过一个非常简单的例子来说明。

```
Q: a_8 = 1+1+1+1+1+1+1+1，a_8的值是多少？
A: 额...数一下...8！
Q: a_9 = a_8 + 1 = 1+1+1+1+1+1+1+1 + 1，a_9的值是多少？这次算快点！
A：9！
Q：为什么这次你算得这么快？
A：因为我知道a_8是多少，只用再加一就行了。
Q：这就是动态规划，每个子问题都可以由已经求解过的子问题来进行求解。你已经知道了a_8的结果，那么就可以很快的算出a_9；接下来，有了a_9的结果，你又可以很快得算出a_10...这样子比暴力求解a_1到a_10要快得多。
```

上面这个例子就是一个很简单但很典型的DP问题。DP的名字中programming的本意是“画表格”，因此DP的本意是在一个部分完成了的表格上，根据已经完成了的部分来动态地填剩下的表格。

然后我们再回到该题目本身，通过一个例子来说明。下面的表格中行和列分别为要匹配的两个字符串，格子中的√或×表示两个字符串相应的前缀串能否匹配上。表中的〇对应的两个前缀串分别是“1*45”和“111111”。很显然，表格的左上角的第一个格子，我们可以根据两个字符串的首个字符的情况直接填写，在这里1和1能匹配，因此是√。接下来，我们可以填写表格的第一行和第一列。横向填写时，若左边已经填好的格子是√且横向的字符串当前字符为'\*'，那么当前格子填√（\*匹配零个字符），否则填×。纵向全部为×，因为纵向的字符串中没有通配符。至此完成了初始化表格的工作。

| |1|*|4|5|6|?|
|-|-|-|-|-|-|-|
|1|√|√|×|×|×|×|
|1|×|
|1|×|
|1|×|
|1|×|
|1|×|
|1|×|
|4|×|
|5|×|
|6|×|
|7|×|

之后，需要按规则来填表，可能出现的情况有4种，假设现在要填的格子为第j行第i列，用s1表示横向的字符串，s2表示纵向的字符串。

1. s1[i]为'*'，那么可以任意匹配。若(j,i)的左侧(j,i-1)、左上(j-1, i-1)或上方(j-1,i)之中有√，那么(j,i)就是√，否则(j,i)是×。如下所示。

| |1|*|4|5|6|?|
|-|-|-|-|-|-|-|
|1|√|√|×|×|×|×|
|1|×|√|
|1|×|√|
|1|×|√|
|1|×|√|
|1|×|√|
|1|×|√|
|4|×|√|
|5|×|√|
|6|×|√|
|7|×|√|

2. s1[i]不是'?'或'*'，也不与s2[j]相同，那么说明不能匹配。(j, i)直接填×。如下所示。

| |1|*|4|5|6|?|
|-|-|-|-|-|-|-|
|1|√|√|×|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|4|×|√|
|5|×|√|
|6|×|√|
|7|×|√|

3. s1[i]与s2[j]相同，说明在这个字符上可以匹配。若(j-1, i-1)是√，那么(j, i)也是√，否则(j, i)是×。如下所示。

| |1|*|4|5|6|?|
|-|-|-|-|-|-|-|
|1|√|√|×|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|1|×|√|×|×|×|
|4|×|√|√|×|×|
|5|×|√|×|√|×|
|6|×|√|×|×|√|
|7|×|√|×|×|×|

4. s1[i]是'?'，那么一定可以在该字符上匹配。与3相同。如下所示。

| |1|*|4|5|6|?|
|-|-|-|-|-|-|-|
|1|√|√|×|×|×|×|
|1|×|√|×|×|×|×|
|1|×|√|×|×|×|×|
|1|×|√|×|×|×|×|
|1|×|√|×|×|×|×|
|1|×|√|×|×|×|×|
|1|×|√|×|×|×|×|
|4|×|√|√|×|×|×|
|5|×|√|×|√|×|×|
|6|×|√|×|×|√|×|
|7|×|√|×|×|×|√|

这样，便可以填完整张表格。最后只需要查看右下角的格子是√还是×就可以判断两个字符串是否能够匹配了。

按照上面的规则，可以得到如下的填表格的代码。其中dp表格与上面例子有所不同，dp[0][0]恒为true，表示两个空前缀一定能匹配上。


```cpp
// 初始化
dp[0][0] = true;    // (0, 0)恒为true，因为空前缀一定能匹配上
for(int i = 1; s1[i] == '*'; i++)   // s1的"*"前缀一定能与空前缀匹配上
    dp[i][0] = true;
// 动态规划
for(int i = 1; s1[i] != '\0'; i++)
    for(int j = 1; s2[j] != '\0'; j++)
    {
        if(s1[i] == '?')        // 情况4
            dp[i][j] = dp[i-1][j-1];
        else if(s1[i] == '*')   // 情况1
            dp[i][j] = (dp[i-1][j-1] || dp[i-1][j] || dp[i][j-1]);
        else if(s1[i] == s2[j]) // 情况3
            dp[i][j] = dp[i-1][j-1];
                                // 情况4，在初始化中全部自动置为false
    }
```