/*****
描述
    给定一个正整数，从这个正整数中删除若干个数字，可以得到一个新的整数。一般而言，采用不同的删除方案，
    可以得到不同的整数。求所有可能的删除方案产生的最小的整数。
    例如：
    1.对于正整数12345，删除3个数字后产生的最小整数为12；
    2.对于正整数543212345，删除5个数字后产生的最小整数为1234；
    3.对于正整数5432102345，删除5个数字后产生的最小整数为2345；
    4.对于正整数137313731373137，删除5个数字后产生的最小整数为1131373137；
    5.对于正整数132304，删除5个数字后产生的最小整数为0。
关于输入
    输入有1行。其中包含两个数：
    第一个数是一个正整数m，表示将要被删除数字的正整数。m的位数小于100。（对于数字123，其位数为3）
    第二个数也是一个正整数k，表示要从第一个数中删除几个数字。两者之间用空格间隔开。
    且保证输入的k小于m的位数。
关于输出
    输出有一行。其中只有一个整数，即：删除若干数字后产生的最小整数。
例子输入
    137313731373137 5
例子输出
    1131373137
提示
    1.输入的正整数m的位数可能会很长，超出一个整型变量的表示范围。
    2.如果删除若干数字后产生了一个首数字为0的非零整数，则在输出时不能输出这些0字符。例如，对于正整数
        5432102345，删除5个数字后产生的最小整数为02345，但在输出时只能输出2345。
    3.如果删除若干数字后产生的整数的值等于0，则只需要输出0。
*****/

#include <iostream>
#include <cstring>
using namespace std;

#define MAX_LEN 110

int min_idx(char* arr, int l, int r)
{
    char _min = '9' + 10;
    int idx = -1;
    for (int i = l; i < r; i++)
        if (arr[i] < _min)
        {
            _min = arr[i];
            idx = i;
        }
    return idx;
}

int main()
{
    char num[MAX_LEN] = "\0";
    int n = 0, len = 0, idx = 0;
    bool flag = true;
    cin >> num >> n;
    len = strlen(num);
    for (int i = len - n; i > 0; i--)
    {
        idx = min_idx(num, idx, len - i + 1);
        if (flag && num[idx] == '0') ;
        else
        {
            flag = false;
            cout << num[idx];
        }
        idx++;
    }
    if (flag)
        cout << 0;
    return 0;
}
