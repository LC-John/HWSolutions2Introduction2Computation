# 2020期中考试

本次考试难度不高，但是对于代码实现的细节以及边界条件重点考察，仅有一道考察算法的题目。

需要同学们着重注意三点：

1. 写代码前一定先想清楚算法，确保自己可以按自己想的算法用纸笔完成所有计算，之后再把自己的想法翻译成代码
2. 编码过程中留心各类边界条件，例如变量为0时是不是会有特殊情况需要处理，矩阵的边角是不是和内部的计算方式相同，...
3. 编码过程中注意细节，养成良好习惯，避免出错，例如数组多开几位防止越界，变量初始化，...

介绍一些比较良好的编程习惯，可能会对下班学期的课程和作业有所帮助。

1. 使用常量（const）和宏定义（#define），而避免直接使用常数。在之前所有作业中，提供的示例代码都会使用宏来定义数据范围。使用宏定义的好处在于，当需要修改经常使用的常数（例如多个数组的数组大小）时，只需要在宏定义处修改即可，而不需要把下面所有常数都修改——直接修改常数很容易发生遗漏，导致代码出错。
2. 数组定义时多开若干位，防止出现边界上数组越界。例如题目要求数组大小为1000，那么实际开数组时就开为1010。
3. 代码可以一边计算一边输出，不需要把所有结果都存下来。这样可以缩小存储大小，也可以避免冗余的这些操作带来的问题。
4. 善用函数，将独立的功能块包成函数，增加代码的可读性。

下面对题目进行逐个分析。

## 甲流病人初筛

最简单的签到题目，基本所有同学都通过了。使用两个判断即可，不再赘述。

## 小于当前数的数

直接考虑最简单的算法可不可以通过——每个数字num[i]都和其他所有数字num[j] (j != i)比较。这种算法首先需要遍历所有的i，对每个i也都需要遍历所有的j，因此算法复杂度是O(n^2)。数据范围为1k，在此复杂度下计算量的量级为1M，完全可以在1s内完成。

因此可以直接使用简单的暴力方法完成本题。

## 换酒问题

记录每一轮喝过的酒cnt，新酒数目b，a个空瓶换1瓶新酒，和当前余下的空瓶emp，则算法如下。

```
1. 喝光新酒,此前的新酒都变为空瓶
    1.1 cnt <- cnt + b
    1.2 emp <- emp + b
2. 用空瓶换新酒
    2.1 b <- emp / a
    2.2 emp <- emp % a
3. 若b <= 0，则不再有新酒，终止并输出cnt
```

初始化时，cnt为0，emp为0，a和b为输入的值。

## 小茗同学很方

直接模拟报数的过程即可。考虑例子输入，即10个人，报数到3出列，求第5个出列的人的编号，整个过程如下所示，最终应该输出7。

| 人 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 出列 |
|-|-|-|-|-|-|-|-|-|-|-|-|
| 报数 | 1 | 2 | 3 |||||||| 3 |

| 人 | 1 | 2 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 出列 |
|-|-|-|-|-|-|-|-|-|-|-|
| 报数 | | | 1 | 2 | 3 ||||| 6 |

| 人 | 1 | 2 | 4 | 5 | 7 | 8 | 9 | 10 | 出列
|-|-|-|-|-|-|-|-|-|-|
| 报数 | | | | | 1 | 2 | 3 || 9 |

| 人 | 1 | 2 | 4 | 5 | 7 | 8 | 10 | 出列 |
|-|-|-|-|-|-|-|-|-|
| 报数 | 2 | 3 | | | | | 1 | 2 |

| 人 | 1 | 4 | 5 | 7 | 8 | 10 | 出列
|-|-|-|-|-|-|-|-|
| 报数 | | 1 | 2 | 3 ||| 7 |

归纳上述过程，可以得到如下的算法直接模拟整个报数过程。

```
假设队伍排列在数组line中，第i-1轮出列的人站在队伍的第cur位，其出列后队伍的长度为n，计算第i轮
1. 第i轮出列的人站在cur + m - 1位，但由于可能会超出队伍长度而绕到队头继续报数，因此实际上第i轮出列的人站在(cur + m - 1) % n位
    1.1 cur <- (cur + m - 1) % n
2. 第cur位的人出列，cur位之后的所有人向前走一位
    2.1 i从cur到n - 1循环
    2.2 line[i] <- line[i + 1]
```

## 重排空格

题目的思路比较简单，但是代码量相对较大。对单词和空格计数，之后输出单词时直接在单词之后输出所需数目的空格即可。下面介绍各个步骤。

首先是计数。对空格计数非常简单，可以直接完成；单词的边界是当前字符为英文字母且当前字符为字符串结尾（下一个字符为'\0'），或当前字符为英文字母且下一个字符为空格，扫描字符串找到所有单词的边界并计数即可。为了方便之后可以直接输出单词，我们一边计数一边将所有空格替换为'\0'，算法如下。

```
1. 空格数和单词数初始化为0
    1.1 n_space <- 0
    1.2 n_word <- 0
2. i从0到字符串长度len循环
3. 若str[i] == ' '，则空格计数并替换为'\0'
    3.1 n_space <-  n_space + 1
    3.2 str[i] <- '\0'
4. 否则，若str[i + 1] == ' '或str[i + 1] == '\0'，则单词计数    # 字符串中字符不是空格就是字母
    4.1 n_word <- n_word + 1
```

计数过后，便可以直接计算每个单词之后需要输出多少个空格：单词之间输出n_space / (n_word - 1)个空格，最后一个单词之后输出n_space % (n_word - 1)个空格。

最后一步，按题目要求输出单词和空格。类似于单词计数，输出时需要找到每个单词的起点——当前字符为英文字母且当前字符为字符串开始，或当前字符为英文字母且前一个字符为'\0'。

## 花生问题

题目直接指定了摘花生的策略，即时间允许的话，直接摘最多的一株，否则返回。因此只需要记录所有花生的数量和位置即可，而不需要把整个田地都存储起来。使用结构体_LOC来进行存储，其定义如下。

```cpp
struct _LOC
{
	int r;
	int c;
	int num;
};
```

为了方便地执行题目要求的策略，还需要对花生按数量进行排序，这里直接使用\<algorithm\>库中的sort函数来对_LOC数组peanut进行排序，当然自己直接实现冒泡排序等也是可以的。sort具有三个参数，第一个参数为待排序的数组的起点地址，第二个参数为终点位置（左闭右开区间表示），第三个参数为比较函数（不填该参数时为默认比较函数）。需要使用的比较函数compare定义，以及sort的使用方式如下。

```cpp
bool compare (_LOC a, _LOC b)
{
	return a.num > b.num;
}
sort(peanut, peanut + np, compare)  // np为peanut的数量
```

在每一步摘花生时，都只需要考虑是摘当前最多的花生，还是放弃采摘回到大路上。可以采摘的前提是，余下的时间足够从当前位置走到最多的花生的位置，并从最多的花生的位置回到大路上；若这一条件无法满足，则只能从当前位置回到大路上，由于在上一步也考虑到了需要从当前位置回到大路上的时间，因此这一定是可行的，不会出现时间不够的情况。实现部分参考示例代码即可。

## 过河问题

过河问题是本次考试中最难的题目，涉及到算法设计，接下来对整个问题和算法进行解析。

首先考虑一下例子输入是如何过河才能得到例子输出的，如下所示。

| 岸 | 对岸 | 接下来的动作 | 当前用时 |
|-|-|-|-|
| 1 2 5 10 | | 1和2过河 | 0 |
| 5 10 | 1 2 | 1返回 | 2 |
| 1 5 10 | 2 | 5和10过河 | 3 |
| 1 | 2 5 10 | 2返回 | 13 |
| 1 2 | 5 10 | 1和2过河 | 15 |
| | 1 2 5 10 | 完成 | 17 |

在这种情况下，为了让最慢的5和10两人的用时重叠，我们首先将最快的两人之一送到对岸，这个人会在最慢的两人过河后把船送回来。因此这种情况下，送最慢的两个人过河（最慢的两人过河，其余人的位置没有变）的用时是次快时间 * 2 + 最快时间 + 最慢时间。但是也存在另一种情况，即次快也非常慢，在这种情况下，很有可能由最快的人来回运送其他人是更优的，考虑如下情况，使用之前的策略如下。

| 岸 | 对岸 | 接下来的动作 | 当前用时 |
|-|-|-|-|
| 1 10 11 12 | | 1和10过河 | 0 |
| 11 12 | 1 10 | 1返回 | 10 |
| 1 11 12 | 10 | 11和12过河 | 11 |
| 1 | 10 11 12 | 10返回 | 23 |
| 1 10 | 11 12 | 1和10过河 | 33 |
| | 1 10 11 12 | 完成 | 43 |

但如果让最快来回往返送人的话，用时如下，明显比之前的策略更优。

| 岸 | 对岸 | 接下来的动作 | 当前用时 |
|-|-|-|-|
| 1 10 11 12 | | 1和12过河 | 0 |
| 10 11 | 1 12 | 1返回 | 12 |
| 1 10 11 | 12 | 1和11过河 | 13 |
| 10 | 1 11 12 | 1返回 | 24 |
| 1 10 | 11 12 | 1和10过河 | 25 |
| | 1 10 11 12 | 完成 | 35 |

考虑了两个具体的例子后，我们可以比较抽象地来讨论如何设计算法。整个过河问题其实可以被拆解为若干步，其中的每一步都是在送最慢的两个人过河（而其他人和船的位置没有发生变化），而最后一步是仅剩的三人或两人过河。

我们首先考虑在多于3个人的情况下，如何送最慢的两个人过河。显然，除了最慢的两个人，还需要有别人的帮助才能让最慢的两人过河并让船回到起始侧的岸边。为了让速度更快，帮忙的人一定是最快的人。下面使用反证法证明若要有人帮忙，则最优情况下帮忙的人必须是最快的人。

```
假设：若需要有人帮忙，最优情况下帮忙的人可以不是最快的人
假设等价于：若需要有人帮忙，则存在某种方案A使得帮忙的人为第i_1,i_2,...,i_m (1<i_1<i_2<...<i_m)快的人，且该方案也是最优的
在上述方案A中：记i_j (1<=j<=m)的过河次数为k_j，最慢的两人n-1和n的过河次数为k_m和k_{m+1}，整个方案A用时为t_A
    显然，t_A = sum_j( k_j * t_{i_j} ) + k_m * t_{n-1} + k_{m+1} * t_n
那么考虑另一种方案B，由1,2,...,m来帮忙，且j (1<=j<=m)所做的事与方案A中i_j所做的完全相同，此时方案B的用时记做t_B
    同样的，t_B = sum_j( k_j * t_j ) + k_m * t_{n-1} + k_{m+1} * t_n
由于方案A是最优的，那么方案B的用时t_B一定会不小于t_A，考虑二者用时的差值，由于t_{i_j} >= t_j
    则有，t_A - t_B = sum_j( k_j * (t_{i_j} - t_j) ) >= 0
取等号的条件是参与到计算中的所有人的速度都相同，而其他情况下一定会存在j使得t_{i_j} > t_j
    那么也就是说，存在某些情况会使得，t_A - t_B > 0，此时t_A > t_B
因此，在某些情况下，A方案不是最优的！出现矛盾！假设不成立！
结论：若需要有人帮忙，最优情况下帮忙的人一定是最快的人
```

然后，我们要证明有人帮忙的情况下，至少需要4趟才可以完成。

```
假设2 * k + 1 (k为自然数)趟可以将最慢的两人送过河，那么此时船在对岸，不符合要求，因此必须偶数趟才可以将最慢的两人送过河
假设2趟可以将最慢的两人送过河
    若无人帮忙，则最慢的两人过河后，必须有一人将船送回，此时送船的人没有过河，不符合要求
    若有人帮忙，则过河的一趟只能是最慢的二人之一和最快的过河，之后最快的人将船送回，而此时最慢的两人中的另一人没有过河，不符合要求
因此2趟不可能将最慢的两人送过河。4趟将最慢的两人送过河的方法在之前的例子中已经展示过，是存在可行的方案的
结论：至少需要4趟才可以将最慢的两人送过河。
```

接下来，我们希望说明在4趟送最慢的两人过河的方案中，只需要前2快的人帮忙即可。由于4趟之中有2趟过河，2趟返回，因此可以过河的船顶多有4个座位，除去最慢的两人一定要上一次船，只余下两个座位。这两个座位顶多能让额外的两人坐上，因此在4趟送最慢的两人过河的方案之中，至多只能有前2快的人可以帮忙。

最后，我们直接罗列所有4趟送最慢两人过河的方案如下，其中有很多不符合要求的方案已经被直接剔除。

| 编号 | 第1趟（过河）后 | 第2趟（返回）后 | 第3趟（过河）后 | 第4趟（返回）后 | 用时 |
|-|-|-|-|-|-|
| 1 | n-1 n \| 1 2 | 1 n-1 n \| 2 | 1 \| 2 n-1 n | 1 2 \| n-1 n | t_1 + t_2 * 2 + t_n |
| 2 | n-1 n \| 1 2 | 2 n-1 n \| 1 | 2 \| 1 n-1 n | 1 2 \| n-1 n | t_1 + t_2 * 2 + t_n |
| 3 | 2 n-1 \| 1 n | 1 2 n-1 \| n | 2 \| 1 n-1 n | 1 2 \| n-1 n | t_1 * 2 + t_{n-1} + t_n |
| ~~4(时间长于3)~~ | 2 n-1 \| 1 n | 1 2 n-1 \| n | 1 \| 2 n-1 n | 1 2 \| n-1 n | t_1 + t_2 + t_{n-1} + t_n |
| 4 | 2 n \| 1 n-1 | 1 2 n \| n-1 | 2 \| 1 n-1 n | 1 2 \| n-1 n | t_1 * 2 + t_{n-1} + t_n |
| ~~5(时间长于3)~~ | 2 n \| 1 n-1 | 1 2 n \| n-1 | 1 \| 2 n-1 n | 1 2 \| n-1 n | t_1 + t_2 + t_{n-1} + t_n |
| ~~5(时间长于3)~~ | 1 n-1 \| 2 n | 1 2 n-1 \| n | 2 \| 1 n-1 n | 1 2 \| n-1 n | t_1 + t_2 + t_{n-1} + t_n |
| ~~5(时间长于3)~~ | 1 n-1 \| 2 n | 1 2 n-1 \| n | 1 \| 2 n-1 n | 1 2 \| n-1 n | t_2 * 2 + t_{n-1} + t_n |
| ~~5(时间长于3)~~ | 1 n \| 2 n-1 | 1 2 n \| n-1 | 2 \| 1 n-1 n | 1 2 \| n-1 n | t_1 + t_2 + t_{n-1} + t_n |
| ~~5(时间长于3)~~ | 1 n \| 2 n-1 | 1 2 n \| n-1 | 1 \| 2 n-1 n | 1 2 \| n-1 n | t_2 * 2 + t_{n-1} + t_n |

显然，这和前面的例子中我们发现了的两种策略相同：最快和次快过河=>最快返回=>最慢和次慢过河=>次快返回（1和2等价），和最快和最慢过河=>最快返回=>最快和次慢过河=>最快返回（3和4等价）。

最后，仅需要考虑在结束的时候，如何处理最后剩下的几个人。若剩2人，则这两人就是所有人之中最快的两人，他们直接过河即可；若剩3人，则这三人是所有人之中最快的三人，由最快分别带过河即可。这里也可以通过反证法证明这是最优的方案。

将上述所有方案组合，即可得到如下的解法。

```
1. 若当前剩余人数n不小于3，则进行如下操作，否则跳至5
2. 取当前最快、次快、最慢和次慢，他们过河的时间分别为a、b、c和d
3. 取a + b * 2 + d和a * 2 + c + d中较小值加到ans之上
4. 最慢的两人过河，剩余人数减2，跳至1
5. 若剩3人，则ans加三人分别的过河时间之和，跳至7，否则跳至6
6. 若剩2人，则ans加较慢的人的过河时间
7. 返回并输出ans
```

这里对算法的证明并不完备，有很多细节没有进行证明。详细的证明可以参考[这里](https://www.cnblogs.com/Scale-the-heights/p/4322338.html)。

## 最短前缀

未知个数的字符串的输入可以通过while(cin)的方式进行，cin在读到EOF（键盘输入的ctrl+z，或测试文件输入的结束）是会返回false，从而终止while循环。具体代码如下。

```cpp
char str[MAX_N][MAX_L + MAX_L]; // 存放输入的字符串
int n = 0;              // 输入的字符串数目

while (cin >> str[n++]);
```

每个字符串的最短前缀的定义为最短的不是其它所有字符串的前缀的前缀，若不存在则为该字符串本身。因此需要从短到长检查每个字符串的前缀是否是其它字符串的前缀。

检查字符串s是否是t的子串可以使用\<cstring\>库中的strstr函数，strstr(t, s)返回s第一次出现在t中的位置（地址），若strstr(t, s)与t相同，则说明s出现在t的首位，即s是t的子串。具体的检查一组字符串str中的第index个的前缀s是否是其它字符串的前缀的函数如下。

```cpp
char str[MAX_N][MAX_L + MAX_L]; // 存放输入的字符串
int n = 0;                      // 输入的字符串数目

bool in(char *s, int index) // s为str[index]的一个前缀
{
    for (int i = 0; i < n; i++)
    {
        if (i == index) // 跳过
            continue;
        if (strstr(str[i], s) == str[i])    // 检查s是否是str[i]的前缀
            return true;
    }
    return false;
}
```

当在前缀中从短到长发现一个不是其他字符串前缀的前缀时，可以直接将其放在str数组中合适的位置处。可以使用\<cstring\>库中的strcat函数来连接两个字符串，strcat(s, t)将字符串t连接在s之后并存放在s之中。对应操作的代码如下。

```cpp
char str[MAX_N][MAX_L + MAX_L]; // 存放输入的字符串
int n = 0;                      // 输入的字符串数目
char pre[MAX_L];                // 存放前缀的临时数组

for (int j = 0; j < strlen(str[i]); j++)
{
    memset(pre, 0, sizeof(pre));    // 清空pre
    strncpy(pre, str[i], j+1);      // 将str[i]的长度为j+1的前缀放入pre中
    if (strcmp(pre, str[i]) == 0    // pre和str[i]相同
        || !in(pre, i))             // pre不是str中其它字符串的前缀
    {
        strcat(str[i], " ");        // 将“ ”放在str[i]字符串之后
        strcat(str[i], pre);        // 将“ ”放在str[i]字符串之后
        break;                      // 此时，str[i]中直接存放的是可输出的结果
    }
}
```

对每个i完成上述操作后，可以直接输出str[i]得到第i个结果。

为了防止超时，我们考虑一下这样直接暴力求解的时间复杂度问题。首先，对每个字符串都有一个i的循环，循环大小为字符串数量n；其次，对每个字符串本身都有一个j的循环，循环大小为字符串长度l；接下来，在判断字符串的in函数之中，还有一个对i的循环，循环大小为字符串数量n；最后，在strstr函数中，假设也是循环判断的，该循环的大小为字符串的长度l。综上，这个解法的复杂度大致为O(n^2*l^2)，代入数据范围发现大约在400M的量级，是可以接受的范围。

当数据量再大时，这一暴力解法将会超时。这时可以对字符串的数组str，使用sort排序，比较函数为strcmp，便可以得到按字典序排序的字符串。在排好序的str之上，只需要比较相邻的字符串便可以得到最短前缀。

除了上面的排序的做法，也可以使用Trie数据结构来完成。这一部分略过。

## 破解密码

题目的题面很长，但是其实难度很低。只要知道将加密的过程逆向进行，就是揭秘的过程。

对于单个字符来说，用a加密或解密b，都需要从字符到数字的转换letter2digit函数以及从数字到字符的转换函数digit2letter，两个函数的实现如下。

```cpp
int letter2digit(char c)
{
    if (c >= 'a' && c <= 'z')   // 小写字母对应0-25
        return c - 'a';
    else                        // 大写字母对应26-51
        return c - 'A' + 26;
}

char digit2letter(int x)
{
    x = (x + 52) % 52;  // 有可能是小于0的数或大于51的数，首先将其转到0-51之间
    if (x >= 26)        // 26-51对应A-Z
        return 'A' + x - 26;
    else                // 0-25对应a-z
        return 'a' + x;
}
```

用a加密b的过程，首先计算a和b对应的数字，之后利用其和计算新的加密的字符b'（求模的一步已经在digit2letter函数中完成）。反过来，用a解密b'的过程，首先计算a和b'对应的数字，之后利用其差（letter2digit(b')-letter2digit(a)）计算解密的字符b。对应的函数如下。

```cpp
char rev(char a, char b_)   // 解密
{
	return digit2letter(letter2digit(b_) - letter2digit(a));
}
```

举个例子如下，按上述步骤进行加密和解密。

| 过程 | a | b | a数字 | b数字 | (b'数字-a数字+52)%52 | (a数字+b数字)%52 | a数字 | b'数字 | a | b'
|-|-|-|-|-|-|-|-|-|-|-|
| 加密=> | 'A' | 'n' | 26 | 13 | -- | 39 | 26 | 39 | 'A' | 'N' |
| 解密<= | 'A' | 'n' | 26 | 13 | 13 | -- | 26 | 39 | 'A' | 'N' |

有了字符级的编解码方法之后，便可以很方便的扩展到字符串上。用字符串a加密字符串b时，只需要a和b上的下标同步移动，且当a上下标移动到'\0'时立刻回退到0，并不断进行字符加密即可。反过来，也是一样的，只不过是进行字符解密。