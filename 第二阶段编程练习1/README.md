# 第二阶段编程练习1

本次作业中主要练习了字符和字符串等操作。“找到不一样的数”和“肿瘤检测”略难，需要有一些算法设计；最后一道“二进制加法”最难，设计大整数运算；除此之外的题目基本没有难度。

需要注意的问题如下。

1. 字符判断时不要直接使用ascii码的数值，能用字符判断就用字符判断。背ascii码是完全没有必要的。

```cpp
c <= '9' && c >= '0'; // OK!
c < = 57 && c >= 48; // 可以，但不建议！考试不会提供ascii码表，要这么写就要背过全部码表。
```

2. 所有字符串都必须以特殊字符'\0'结尾，也就是说在定义字符串时需要留出一个额外的位置给'\0'，否则有可能在边界条件时触发数组越界。

## 大小写字母

直接判断输入字符在以下哪个区间即可。

```
对于输入字符c
1. 如果c <= 'Z'且c >= 'A'，则c是大写字母
2. 否则如果c <= 'z'且c >= 'a'，则c是小写字母
3. 否则c不是字母
```

## 与3无关的数

参考第一阶段编程练习4中的“数字7游戏”，不再赘述。

## 计算圆柱体的表面积

直接按照公式计算即可，不再赘述。

## 统计字母和数字的个数

不断读入不含空格的乱码单词（只包含数字和大小写字母），之后逐个统计单词中的字符即可。

当然，可以使用while(cin)的方式方便地读入单词，也可以通过cin.getline()的方式直接读入整行。统计字符时要注意字符串以'\0'结尾。

## 找到不一样的数

可以利用在之前介绍过的异或运算来方便地完成本题。异或运算（XOR运算，C/C++中用“^”表示）是一种位运算，输入两bit相同时输出0，不同时输出1，如下表所示。

|XOR|0|1|
|-|-|-|
|0|0|1|
|1|1|0|

基于这样的性质，可以证明，对于m和n这任意的两个bit，都有m^n^n == m；这个性质可以推广到整型上，对任意整型m和n，都有m^n^n == m。因此，1在和一个数字做奇数次XOR后会得到那个数字，而偶数次XOR后还是1本身。这样的话，只需要对整个输入的序列做XOR，最后就能直接得到出现了奇数次的那个数字，如下所示。

```cpp
#include <iostream>
using namespace std;
int main()
{
    int n = 0, num = 0, res = 0;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> num;
        if (res <= 0)
            res = num;
        else
            res ^= num;
    }
    cout << res;
    return 0;
}
```

当然，也可以不用XOR，采用计数的方法来完成。参考示例代码即可。

## 肿瘤检测

该题目需要使用二维数组完成。在读入数据后，扫描各点计数即可。

```
给定图像image，在扫描至(i,j)点时，此时周长为C，面积为S
1. 若image[i][j] <= 50，则该点是肿瘤
    1.1 更新S，S += 1
    1.2 若(i,j)位于图像边界，则该点是肿瘤的边界点
        1.2.1 更新C，C += 1
    1.3 否则，检查(i,j)上下左右的四点(i',j') in {(i+1,j) (i-1,j) (i,j+1) (i,j-1)}
        1.3.1 若image[i'][j'] > 50，则(i',j')不是肿瘤，且(i,j)是肿瘤的边界点
            1.3.1.1 更新C，C += 1
2. 扫描下一个点
```

## 二进制加法

该题目为本次作业中最难的题目，需要谨慎考虑算法。

首先，将二进制转为十进制后直接运算的方法是不可行的，因为题目要求中表明最长的二进制数有100bit，而目前可用的最长的整型unsigned long long int只有64bit——强行转为二进制一定会导致溢出出错。

因此，我们只能像列竖式一样进行运算。列竖式有几个基本的步骤——a) 对齐两数各位，b) 逐位计算并记录进位，c) 输出结果。

我们可以考虑一个例子，来理解这个过程，假设我们有两个字符数组a和b，分别来记录两数（方便起见，我们假设a不比b短，真实情况下，可以通过交换a和b的方式来保证这一要求），在刚输入时的情况如下。此时，a和b的各位并没有对齐。

|各位|64|32|16|8|4|2|1||
|-|-|-|-|-|-|-|-|-|
|a|'1'|'0'|'1'|'0'|'1'|'0'|'1'|'\0'|

|各位|32|16|8|4|2|1|||
|-|-|-|-|-|-|-|-|-|
|b|'1'|'0'|'1'|'0'|'1'|'0'|'\0'|'\0'|

对齐的方式有两种，一种是把b右移，并不断在左侧补'0'；另一种方式是两个数组倒置，并在b的右侧补'0'。我们采取第二种方式，将a和b倒置。

|各位|1|2|4|8|16|32|64|||
|-|-|-|-|-|-|-|-|-|-|
|a|'1'|'0'|'1'|'0'|'1'|'0'|'1'|'\0'|
|b|'0'|'1'|'0'|'1'|'0'|'1'|'\0'|'\0'|

之后在b右侧补'0'，直至与a一样长。至此完成对齐。

|各位|1|2|4|8|16|32|64|||
|-|-|-|-|-|-|-|-|-|-|
|a|'1'|'0'|'1'|'0'|'1'|'0'|'1'|'\0'|
|b|'0'|'1'|'0'|'1'|'0'|'1'|'0'|'\0'|

接下来，我们从左向右逐位进行计算，将结果存到res数组中，使用一个字符c记录进位情况，初始时c = '0'。在第i位时，res[i]和c的计算规则如下。

|a[i]+b[i]+c (old)|res[i]|c (new)|
|-|-|-|
|0|0|0|
|1|1|0|
|2|0|1|
|3|1|1|

整个计算结果如下。至此完成计算。

|各位||1|2|4|8|16|32|64|||
|-|-|-|-|-|-|-|-|-|-|-|
|a|   |'1'|'0'|'1'|'0'|'1'|'0'|'1'|'\0'|
|b|   |'0'|'1'|'0'|'1'|'0'|'1'|'0'|'\0'|
|res| |'1'|'1'|'1'|'1'|'1'|'1'|'1'|'\0'|
|c|'0'|'0'|'0'|'0'|'0'|'0'|'0'|'0'||

最后，需要将结果输出。输出时首先要判断在最高位上是否产生进位，若产生了进位则要先输出进位，否则从右向左输出res。该示例上，最高位没有进位，则从右向左会输出res，在屏幕上打印出"1111111"。