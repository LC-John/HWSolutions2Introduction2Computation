/*****
描述
    经历过和S星人的交流之后，他已经对任何交流上的差异都不感到奇怪了。然而这一次，他在和一个A国同学合作时又出现了
    让他大跌眼镜的事情。那个同学给他的实验数据是用科学计数法表示的，而他需要正常的保留小数点后6位的双精度浮点数。
    可是不同于我们用2e5来表示200000，他们会使用任何一个字母或者数字中不会出现的字符来表示乘方。这下可麻烦了，本来
    好好的用atof()函数就解决了，现在这个写好的函数就没法用，只好自己写一个了。阿福为了这份数据已经熬了好几个通宵了，
    想让你趁他睡觉把这个问题处理一下，你一定可以做到的！
    （助教哥哥友情提醒，题目较长，记得看提示）
关于输入
    输入多个数字型的字符串，每个字符串之间换行符隔开。字符串可能包括正负符号、小数点以及代表乘方的字符（不是数字，
    正负号，小数点）。
    对输入的字符串进行转换时，遇见数字、小数点或正负符号就开始做转换，字符串结束时才结束转换，并将结果返回。
    当输入字符'q'时，程序结束。
关于输出
    double型浮点数，显示小数点后六位。
    当为正数时，浮点数第一位不显示'+'。
    当为负数时，浮点数第一位显示'-'.
例子输入
    +2343.12
    -2.36542
    -5.21
    6.348
    +0.564f5
    +0.456
    -25.1f-5
    q
例子输出
    2343.120000
    -2.365420
    -5.210000
    6.348000
    56400.000000
    0.456000
    -0.000251
提示
    注意：本题严禁使用stdlib.h中的atof()函数，否则不得分。
*****/

#include <cstdio>
#include <cstring>

#define MAX_LEN 100

char num[MAX_LEN] = "\0";

int main()
{
    while (scanf("%s", num))
    {
        double res = 0;
        if (strlen(num) == 1 && num[0] == 'q')
            break;
        for (int i = 0; num[i] != '\0'; i++)
            if ((num[i] < '0' || num[i] > '9') && !(num[i] == '+' || num[i] == '-' || num[i] == '.'))
                num[i] = 'e';
        sscanf(num, "%lf", &res);
        printf("%.6lf\n", res);
    }
    return 0;
}
