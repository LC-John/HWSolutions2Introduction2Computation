/*****
描述
    菜鸟大神常常遇到一些感情方面的问题，这不，上周又刚被一MM拒绝......
    菜鸟大神十分沮丧，晚上他独自走在荒凉的街道上，看着街旁一排昏暗而破旧的路灯，眼中充满了无尽的忧伤......
    他打算把心中的一切情绪发泄在路灯上。
    假设一共有n盏路灯排成一排，每次操作菜鸟大神选择所有路灯中的2盏(2盏可能相同)，然后把两盏灯之间(包括这两
    盏)中所有路灯开关都拨动一次，这样原来开着的路灯关闭，关着的灯就打开。
    菜鸟大神想知道，经过t次操作之后，大概有多少盏路灯是打开的?
关于输入
    第一行是一个数T (T<=120) ，表示有T组测试数据。
    每组测试数据第一行有两个数n, t (1<=n<=10^4 0<=t<=10^4) 第二行是n个值为1或0的整数，表示路灯的初始状态，
    1代表打开，0代表关闭。
关于输出
    对于每组测试数组，首先输出"Case #X: "，X代表测试用例的编号，具体可参见sample output. 然后输出一个实数，
    表示t次操作后大概有多少灯亮着，保留4位小数.
例子输入
    2
    1 1
    0
    4 0
    1 1 0 1
例子输出
    Case #1: 1.0000
    Case #2: 3.0000
*****/

#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

int main()
{
	int K;
	cin >> K;
	for (int h = 0; h < K; ++h) {
		int t, n, tmp;
		double res = 0;
		cin >> n >> t;
		for (int i = 0; i < n; ++i) {
			cin >> tmp;
			double p = i * (n - i) + (n - i - 1) * (i + 1) + n;
			p = p / n / n;
			double p1 = (1 - pow(1 - 2 * p, 1.0 * t)) / 2;	// 伯努利事件发生奇数次的概率，二项式定理
			double p2 = 1 - p1;
			if (tmp == 1)
				swap(p1, p2);
			res += p1;
		}
		printf("Case #%d: %.4lf\n", h + 1, res);
	}
	return 0;
}
