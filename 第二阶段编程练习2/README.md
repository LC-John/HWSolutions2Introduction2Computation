# 第二阶段编程练习2

本次作业相对难度不大，但需要灵活运用之前作业中用到的一些算法。

## 挂号医师

基本没有难度。在读入队伍长度数据的同时，寻找最短的队伍；之后再遍历一次队伍长度，找到第一个最短的队伍即可。

## 求特殊自然数

需要运用到之前作业中用过的计算各位数码的方法，由于这里有七进制数有九进制数，所以需要有取出任意进制数码的函数如下。

```cpp
int num_scale[MAX_N] = {0}; // 结果存放在数组中，从左到右为低位到高位（与直接书写相反）
void get_digits(int num, int scale)    // 输入十进制数num和目标进制scale
{
    for (int i = 0, tmp = num;      // i表示当前计算到目标进制的第几位
         tmp > 0;               
         i++,tmp /= scale)          // tmp在目标进制下不断右移
        num_scale[i] = tmp % scale; // 保存tmp在目标进制下的最右位（对应十进制下个位）
    return;
}
```

有了这一函数后，便可直接方便的计算。为了简化计算过程，我们只需要从九进制数下最小的三位数（九进制下的100，对应十进制下1*9*9=81）检查到七进制下最大的三位数（七进制下的666，对应十进制下6*7*7+6*7+6=342）。

## 不与最大数相同的数字之和

第一阶段编程练习2中的原题目，不再赘述。

## 校门外的树

基本没有难度，直接模拟砍树的过程即可。需要注意的是，从0到L一共有L+1棵树。

## 寻找素数之差仍为素数的素数对序列

这是一道比较难的题目，需要比较精确的控制算法复杂度，否则大概率会超时。首先，这是一个与素数有关的题目，那么我们的第一步肯定就是要产生某个区间里面的所有素数；其次，题目中要检查一对数是否是素数，以及它们的差是否是素数，这意味着我们需要有能够快速判定一个数是不是素数的方法。

在之前的作业中介绍过的方法也可以使用，但是复杂度比较高，有超时的风险。之前介绍的算法的基本思路是“不能整除比自己小的素数的数一定是素数”，因此我们只需要不断记录已知的素数，并用它们去检查更大的数是不是素数即可。代码如下。这个算法，只能找到所有素数，但无法完成快速查询。我们可以根据prime数组构造is_prime数组，is_prime[i]表明i是否是素数。有了is_prime数组后，便可以非常快速地查找任意一个在范围内的数是否是素数。

```cpp
int prime[MAX_N] = {2}, n_prime = 1;    // 数组prime存放所有找到的素数，n_prime指明当前素数的个数
void generate_prime(int _max)           // 函数将找出从2到_max的所有素数
{
    for (int i = prime[n_prime-1] + 1; i < _max; i++)   // 遍历检查i
    {
        bool flag = true;                   // flag指示i是否是素数
        double sqrt_i = sqrt(i);
        for (int j = 0; prime[j] <= sqrt_i; j++)   // 用prime中小于等于根号i的素数来检查i
            if (i % prime[j] == 0)          // i可以被素数prime[j]整除
            {
                flag = false;               // 则i不是素数
                break;
            }
        if (flag)                           // i是素数
            prime[n_prime++] = i;           // 将i存到prime数组中，计数加一
    }
    return;
}
```

在这里我们使用筛法来求素数，这个方法是目前已知最快的算法。筛法的基本思路是“素数的整数倍都不是素数”。举个例子，初始时我们并不知道从2到n所有数字是否是素数；从2起到n，我们不断将2的整数倍标记为不是素数；接下来，可以发现最小的素数是3，则从3起到n，不断将3的倍数标记为不是素数；...；已知持续到sqrt(n)也就是根号n。筛法求素数的函数如下。

```cpp
int is_prime[MAX_N] = {0};
void generate_prime(int n)
{
    double sqrt_n = sqrt(n);
    memset(is_prime, -1, sizeof(is_prime)); // 初始化，所有数都认为可能是素数
    is_prime[0] = 0;    // 0不是素数
    is_prime[1] = 0;    // 1不是素数
    for (int i = 2; i <= sqrt_n; i++)
    {
        if(!is_prime[i])    // i不是目前未知的最小的素数
            continue;
        for (int j = i * 2; j <= n; j += i) // 找到目前未知的最小素数，遍历其所有整数倍
            is_prime[j] = 0;    // 将i的整数倍全部标记为非素数
    }
}
```

筛法可以高效得找出所有素数，满足了第一个要求，除此之外也直接构造好了is_prime数组，可以直接进行快速查询。