# 第三阶段编程练习1

## 输出二进制补码

该题目考察到位运算操作。符号整型数据直接按照补码存储，因此可以直接按位输出。按位取int类型各位的代码如下，将各位取出后，倒序输出即可。

```cpp
for (int idx = 0; idx < INT_LEN; num = num >> 1)    // 右移，去除最低位
    bin[idx++] = num & 1;   // 取最低位
```

题目要求里终止条件是输入一个字母，因此还需要区分处理输入的字符串。将输入数据存放在字符串str中，若str[0]是字母，则终止；否则计算和输出二进制补码。将字符串str转为int类型的num可以使用\<cstdio\>中的sscanf函数，如下。

```cpp
sscanf(str, "%d", &num);
```

## 取石子游戏

按照题目要求进行模拟即可。

用A和B表示两堆石子数目，若A / B或B / A大于等于2，则对一人来说存在必胜策略，终止模拟；否则，从多的一堆取出少的一堆那么多的石子（假设A > B，则从A中取出B个），并进入下一轮迭代，直到出现必胜的情况或某一堆石子取空。

## 拔牙

该题目是典型的深度优先搜索（DFS，Depth First Search），可以使用递归轻松的解决。

深度优先的递归实现方法存在一些共同点，比较典型的框架如下。

```cpp
int func(char** argv) // 函数定义，以及一些参数，argv代表了整个状态树中的一个节点
{
    int ret;
    if (IS_LEAF(argv))  // 终止条件，搜索到叶节点
        return SOMETHING;   // 该条路径已经搜索到底，返回结果
    for (int i = 0; i < N_CHILD(argv); i++)  // 遍历搜索所有argv之下的子结点
    {
        argv = CHILD(argv)  // 访问argv代表的节点之下的子节点
        ret += func(argv)   // 得到argv节点下子节点的结果，增量式存储到ret中
        argv = PARENT(argv) // 恢复argv，从子节点回到父节点，一遍下一次搜索
    }
    return ret; // 返回argv节点及其以下子树的搜索结果
}
```

对于该题目来说，某个节点A存在两个子节点B和C，对应的是拔牙拔到了若干颗时（A），接下来可以再拔一颗（B）或者再拔两颗（C）。整个DFS递归的实现如下。

```cpp
int func(int left, int cnt) // left为还剩下多少颗牙需要拔，cnt为搜索到目前为止找到了多少方案
{
    if (left < 0)   // left为负数，说明当前正在搜索的路径是错误的，拔掉的牙的数目不可能多过牙的数目
        return cnt; // 因此，直接返回cnt不变，这条搜索路径不是可行的拔牙方案，没有找到新的拔牙方案
    else if (left == 0) // left为0，说明恰好拔完了牙，出现了一个可行的拔牙方案
        return cnt + 1; // cnt加一，DFS确保不会重复访问，所以这一条路径对应的方案一定是一个新的方案
    cnt = func(left - 1, cnt);  // 子节点B，再拔一颗牙
    cnt = func(left - 2, cnt);  // 子节点C，再拔两颗牙
    return cnt; // 完成搜索，返回
}
```

## 最小公倍数

该题目同样是在考察递归。如果可以使用func(a, b)函数计算a和b的最大公因数，那么可以直接得到a和b的最小公倍数为a * b / func(a, b)。使用辗转相除法计算最大公因数的函数如下。

```cpp
int func(int a, int b)
{
	if (a % b == 0)
		return b;
	else
		return func(b, a % b);
}
```

## 一种等价类划分问题

第一阶段编程练习4中的题目，不再赘述。

## 回文数判断

与第二节点编程练习5中的“判断字符串是否为回文”相同，不再赘述。

## 487-3279

简单考虑一下如何存储电话号码以及如何对电话号码进行计数——电话号码都是8位的数字，因此完全可以使用int类型来直接表示；同样的，可以直接使用数组来计数，cnt[i]表示i对应的电话号码出现的次数。

其余难度均在代码实现上，可以直接参考提供的代码。

## 玛雅历

该题目是简单的日子计算，算法和实现都基本没有难度，可以直接参考提供的代码。